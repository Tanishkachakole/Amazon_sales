create database amazon;
use amazon;
-- top selling products 
-- query the top 10 products by total sales value 
-- include product name , total_quantity sold and total value 

SELECT 
    p.product_id,
    product_name,
    SUM(quantity) AS total_order,
    SUM(oi.total_price) AS total_sale
FROM
    products p
        JOIN
    order_items oi ON p.product_id = oi.product_id
GROUP BY product_id , product_name
ORDER BY total_sale DESC
LIMIT 10;

-- 2. revenue by category 
-- calculate the total revenue generated by each product category
-- chalange : include the percentage of contribution of each category to total revenue
 
SELECT 
    category_name,
    SUM(total_price) AS total_revenue,
    CONCAT(ROUND(SUM(total_price) / (SELECT 
                            SUM(total_price)
                        FROM
                            order_items) * 100,
                    2),
            '%') AS contribution
FROM
    category c
        JOIN
    products p ON c.category_id = p.category_id
        JOIN
    order_items oi ON p.product_id = oi.product_id
GROUP BY category_name
ORDER BY contribution DESC;

-- average order value compute the average order value for each customer 
-- challenge : include orders only customer with more than 5 orders

SELECT 
    c.customer_id,
    CONCAT(c.f_name, ' ', c.l_name) AS name,
    COUNT(o.order_id) AS orders,
    SUM(total_price) / COUNT(o.order_id) AS average_spent
FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    order_items oi ON o.order_id = oi.order_id
GROUP BY c.customer_id , name
HAVING orders > 5
ORDER BY orders DESC;

-- monthly sale trend 
-- monthly total sales over the past year 
-- challenge: display the sales trend, grouping by month, 
-- return current_month sale , last month sales:

select year,month,current_month,lag(current_month,1)over(order by year,month) as last_month from (
select extract( month from order_date) as month, extract( year from order_date) as year ,
round(sum(total_price),2) as current_month
from
 orders o join order_items oi on o.order_id = oi.order_id
 where order_date=2025 
 group by month,year
 order by month) t1;
 
 -- 5. customer with no purchases find customers who have resistered but never an orders
 -- challange list customer detail and thw=e time since their 
 ##1st approach 
SELECT 
    *
FROM
    customers
WHERE
    customer_id NOT IN (SELECT DISTINCT
            customer_id
        FROM
            orders);
##2nd approach
SELECT 
    *
FROM
    customers c
        LEFT JOIN
    orders o ON c.customer_id = o.customer_id
WHERE
    o.customer_id IS NULL;
    
-- 6. best selling category by state identify the best-selling category for each states 
-- challenge : include the total sales for that category within the state

with states_revenue as
	 (  
        select  
            c.state,
            category_name,
            round(sum(oi.total_price),2) as total_spent, 
            rank() over(partition by state order by sum(oi.total_price) desc) as ranking 
		from customers c 
        join 
        orders o on c.customer_id=o.customer_id 
        join   
        order_items oi on oi.order_id = o.order_id 
        join 
        products p on o.product_id = p.product_id 
        join  category ca on ca.category_id= p.category_id 
        group by c.state,category_name 
	)  
select * from states_revenue where ranking = 1;

-- 7. customers lifetime alue spent (cltv)
-- calculate the total value of order placed by eqach customers over their lifetime 
-- challenge:  rank customerbased on their cltv 


select 
     c.customer_id,concat(f_name,' ',l_name) as name ,round(sum(total_price),2) as total_spent, 
     dense_rank() over(order by round(sum(total_price),2) desc) ranking
from
 customers c join orders o on c.customer_id = o.customer_id join order_items oi on oi.order_id=o.order_id
group by 
  c.customer_id,name order by total_spent desc ;
  
  
  -- 8 inventory stock alert 
  -- query : products with stock levels below a certain threshold (e.g less than 10 unites )
  -- challenge: include last stock date and warehouse information 

use amazon;
SELECT 
    p.product_id,
    product_name,
    stock_remaining,
    warehouse_id,
    restock_date
FROM
    inventory i
        JOIN
    products p ON i.product_id = p.product_id
WHERE
    stock_remaining <= 10 
order by 
     stock_remaining ;
     
-- 9 shipping delay 
-- identify the orders that shipping date is later than 3 days after the order date 
-- challenge include customer detail ,order detail and deilivery provider 
SELECT 
    c.*, o.*, order_date, shipping_date
FROM
    shipping s
        JOIN
    orders o ON s.order_id = o.order_id
        JOIN
    customers c ON o.customer_id = c.customer_id
WHERE
    ABS(DATEDIFF(STR_TO_DATE(order_date, '%Y-%m-%d'),
                    STR_TO_DATE(shipping_date, '%Y-%m-%d'))) < 3;

-- payment success rate 
-- calculate the percentage of successful payment across all orders 
-- challange : incluse breakdown by payments staus (e.g, failed,pending)


SELECT 
    payment_status,
    CONCAT(COUNT(payment_status) / 21000 * 100, '%') AS percentage_of_payments
FROM
    payments
GROUP BY payment_status;

-- 11. top performing salerss 
-- find top 5 sellers based on total sales value 
-- challenge include both successful and failed orders,and display their percentage of successful orders

with top_seller as (SELECT 
    s.seller_id,seller_name,
    sum(total_price) as total_sales
FROM
    sellers s
        JOIN
    orders o ON s.seller_id = o.seller_id
         join 
	order_items oi on o.order_id = oi.order_id 
GROUP BY seller_id , seller_name
ORDER BY total_sales desc limit 5) ,
order_status as (
select seller_id ,order_status,count(order_status) as count_of_orders 
from orders
where order_status <> 'Returned' and order_status <> 'Pending'
group by seller_id,order_status
) ,
seller_report as (select t.*, os.order_status, os.count_of_orders
from top_seller t join order_status os on t.seller_id = os.seller_id
 order by seller_id )
 select 
    seller_id,
    seller_name,
    sum(case when order_status = 'Delivered' then count_of_orders  else  0 end) as deliverd_order,
	sum(case when order_status = 'Cancelled' then count_of_orders  else  0 end) as cancelled_order,
	sum(count_of_orders) as sum ,
    sum(case when order_status = 'Delivered' then count_of_orders  else  0 end) /sum(count_of_orders) * 100 
    as percentage_ofsuccessuful_order
from seller_report group by seller_id,seller_name;


-- 12 product profile margine 
-- calculate the total profit margine for each product difference between price and cost of good sold 
-- ranked product by their total margine , showing highest to the lowest 

select 
     product_id,product_name,
     round(price-cogs,2) as margine ,
     rank()over(order by round(price-cogs,2) desc) as ranking
from 
     products; 

-- 13 most  returned   products 
-- query : top 10 products number of returned 
  
 use amazon;
 
  SELECT 
    p.product_id,
    product_name,
    COUNT(order_status) AS total_sold,
    SUM(CASE WHEN order_status = 'Returned' THEN 1 ELSE 0 END) AS returned,
    CONCAT(SUM(CASE WHEN order_status = 'Returned' THEN 1 ELSE 0 END) / COUNT(order_status) * 100,'%') 
    AS return_percentage
FROM
    products p
        JOIN
    orders o ON p.product_id = o.product_id
GROUP BY p.product_id , product_name
ORDER BY returned DESC
LIMIT 10;

-- 14 identify inactive sellers 
-- identify seller who havent made any sale in 6 month 
-- challange show the last sale date and total sales from those saller

SELECT 
    s.seller_id,
    seller_name,
    MAX(order_date) AS last_sale_date,
    COUNT(*) total_sales
FROM
    orders o
        JOIN
    sellers s ON o.seller_id = s.seller_id
GROUP BY seller_id , seller_name
HAVING last_sale_date <= DATE_SUB(CURDATE(), INTERVAL 6 MONTH);

 -- 15 if the customers returning their order more then 5 then categeroize them returning oe or new 
 -- challenge : customer_id , total_order, ,returning
 
 SELECT 
    customer_id,
    COUNT(order_id) AS total_order,
    SUM(CASE
        WHEN order_status = 'Returned' THEN 1
        ELSE 0
    END) AS total_return,CASE
        WHEN
            SUM(CASE
                WHEN order_status = 'Returned' THEN 1
                ELSE 0
            END) > 5
        THEN
            'Returning'
        ELSE 'new'
    END AS categorize
FROM
    orders
GROUP BY customer_id;

-- 16. top 5 customer which order in each state 
-- identify the top 5 customer with highest number of order of each state 
-- include the total number of order and total sale 


select * from (
SELECT 
    c.customer_id,concat(f_name ,' ' ,l_name) as customer_name,state , count(o.order_id) as total_order ,
    dense_rank() over(partition by state order by count(o.order_id) desc) as ranking
 FROM
    customers c
        JOIN
    orders o ON c.customer_id = o.customer_id
        JOIN
    order_items oi ON o.order_id = oi.order_id 
group by    c.customer_id,customer_name,state order by state) t1 where ranking <=5 ;

-- 17. top 10 product with highest decreasing revnue ratio as compare to last year 2024 and current year 2025 
-- return product_id , product_name ,2024 revenue and 2025 revenue decrease ratio at 

 with 2024_revenue as (SELECT 
    p.product_id,product_name,extract(year from order_date) as year,sum(total_price)  as 2024_sales
FROM orders o
        JOIN
    products p ON o.product_id = p.product_id
        JOIN
    order_items oi ON o.order_id = oi.order_id
group by  p.product_id,product_name,year 
having year = 2024
order by product_id),
2025_revenue as (SELECT 
    p.product_id,product_name,extract(year from order_date) as year,sum(total_price)  as 2025_sales
FROM orders o
        JOIN
    products p ON o.product_id = p.product_id
        JOIN
    order_items oi ON o.order_id = oi.order_id
group by  p.product_id,product_name,year 
having year = 2025
)
select
	  r.product_id,r.product_name ,
	  round(2024_sales ,2) as 2024_sales,
      round(2025_sales,2) as 2025_sales,
      round(2024_sales -  2025_sales,2)  as rev_diff,
     round( (2025_sales -  2024_sales )/ 2024_sales * 100 ,2) as ratio 
from 2024_revenue r join 2025_revenue e  on  r.product_id = e.product_id 
where 2024_sales > 2025_sales
 order by ratio 
 limit 10 ;    

-- final task --
-- create procedure 
-- create a function as soon as the product is sold the same quantity should reduce from inventory table 
-- after adding any sales records it should 
-- update the stock in the inventory table based on the product and qty purchased 

use amazon;

select * from inventory ;
select *  from orders;
select * from order_items ;
-- order_id , customer_id,customer_id,product_id,seller_id


delimiter $$ 
create procedure  add_sales( 
p_order_id int, p_customer_id int ,p_seller_id int ,
p_order_item_id int , p_quantity int ,p_product_id int
)
begin
   declare v_count int ; 
   declare v_price float ;
   declare v_product varchar(50);
   -- all our code and logic 
   -- first check enter product_id is have in stock 
   select price ,product_name into v_price,v_product from products where product_id = p_quantity ;
   
	select count(*) into v_count 
    from inventory where product_id = p_product_id and stock_remaining >= p_quantity ;
    if v_count > 0  then 
     -- add into orders and order_item and update inventory
     insert into orders(order_id,order_date,customer_id,product_id,seller_id)
     values (p_order_id,current_date,p_customer_id,p_product_id,p_seller_id);
     insert into order_items(order_item_id,order_id,product_id,quantity,price_per_unit,total_price)
     values (p_order_item_id, p_order_id,p_product_id,p_quantity,v_price,v_price * p_quantity) ;
     -- update inventory 
     update inventory 
     set stock_remaining = stock_remaining - p_quantity where product_id = p_product_id ;
     select 'Thank you product : % added and also inventory stock updated',v_product  message; 
	else
     select 'product are not available' message ;
     
  
  end if ;
    
end $$ 
delimiter ;

call add_sales(21002,2098,5,21002,94,5);
-- p_order_id int, p_customer_id int ,p_seller_id int ,
-- p_order_item_id int , p_quantity int ,p_product_id int
select * from inventory where product_id = 5; 
select  *  from order_items where order_id = 21002;

select * from inventory where product_id = 1 and stock_remaining >= 100